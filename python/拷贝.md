# python深浅拷贝

> 用等号赋值时只是把一个变量的指向给另一个变量

- 当我们使用等号给**列表或字典**赋值时，会遇到下面这种情况

```python
a = [1, 2, 3]
b = a
id(a)   # 2346126171648
id(b)   # 2346126171648
b[2] = 4
a   # [1, 2, 4]
```

- a、b的id是一样的
- 改变b的同时a的也被改变了

> CPython 中 id() 函数用于获取对象的内存地址。

那有什么可以使b的改变不会使a也改变吗？

## 浅拷贝（copy.copy）

> 拷贝变量的内容，但只拷贝一层

- 下面来这个例子

```python
import copy
a = [1, 2, 3]
c = copy.copy(a)
id(c)   # 2346126171648
id(c)   # 2346164832256
c[0] = 2
a   # [1, 2, 3]
c   # [2, 2, 3]
```

- a、c的id不一样
- c的改变不影响a

- 那什么又是只拷贝一层呢，**当我们的列表(字典)嵌套另一个列表(字典)时**，比如下面的

```python
import copy
a = [1, 2]
b = [3, 4]
c = [a, b]
d = copy.copy(c)
id(c)   # 2346164487872
id(d)   # 2346166365440
id(a)   # 2346168932224
id(c[0])   # 2346168932224
id(d[0])   # 2346168932224
```

- 可以看到c、d的id是不一样的，但他们的第一个元素的id是一样的,都是a的id
- c的改变时d也改变了

而要使拷贝变量里面的全部内容，并且两个变量之间不在相互影响，这就要用到深拷贝了

## 深拷贝（deepcopy）

> 拷贝对象的内容，进行深层次的拷贝，拷贝后两个变量不在相互影响

```python
import copy
a = [1, 2]
b = [3, 4]
c = [a, b]
d = copy.deepcopy(c)
id(c)   # 2346164487872
id(d)   # 2346166365440
id(a)   # 2346168932224
id(c[0])   # 2346168932224
id(d[0])   # 2346168488832
```

- c、d的id不一样，同时他们里面的元素的id也不一样了，c、d相互不影响

下面我们再来看一个例子

```python
import copy
a = [1, 2]
b = [a, a]   # [[1, 2], [1, 2]]
c = copy.deepcopy(c)
c[0][0]   # 1
c[0][0] = 3
c   # [[3, 2], [3, 2]]
```

- 可以看到c中的两个1都被改变了
- 说明在一个列表b嵌套另一个列表a时，如果其中b中有两个列表a，使用**deepcopy**时，只会重新创建一个列表a，而不是创建两个列表
